# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TFm_4iowgzfFyvOYGQ567wkNls6T7WiO
"""

import numpy as np

class ttt():
  def __init__(self,size=(3,3)):
    self.turn = -1
    self.win = None
    self.board = np.zeros(size)
    self.x = size[0]
    self.y = size[1]
    
  def check(self):
    empty = False
    for x in range(len(self.board)):
      scoreX = 0
      scoreY = 0
      for y in range(len(self.board[x])):
        if self.board[x][y] == 0:
          empty = True
        scoreX += self.turn*self.board[x][y]
        scoreY += self.turn*self.board[y][x]
      if scoreY == 3 or scoreX == 3:
        self.win = self.turn
        return
    score = 0
    score += self.turn*self.board[0][0]
    score += self.turn*self.board[1][1]
    score += self.turn*self.board[2][2]
    if score == 3:
       self.win = self.turn
       return
    score = 0
    score += self.turn*self.board[0][2]
    score += self.turn*self.board[1][1]
    score += self.turn*self.board[2][0]
    if score == 3:
       self.win = self.turn
       return
    if self.win == None and not empty:
      self.win = 0
      return
  def game_end(self):
    if self.win == None:
      return
    if self.win == 0:
      print("no win")
      return
    if self.win == 1:
      print("O wins")
      return
    if self.win == -1:
      print("X wins")
      return
    return

  def valid_moves(self):
    valid_moves = []
    if self.win != None:
      return valid_moves
    for x in range(len(self.board)):
      for y in range(len(self.board[x])):
        if self.board[x][y] == 0:
          valid_moves.append((x,y))
    return valid_moves

  def play(self,x,y):
    if self.win != None:
      self.check()
      return
    if x >= self.x or x < 0:
      print('Invalid move')
      return
    if y >= self.y or y < 0:
      print('Invalid move')
      return
    if self.board[x][y] != 0:
      print('Invalid move')
      return
    if self.turn == -1:
     self.board[x][y] = -1
     self.check()
     self.turn = 1
    elif self.turn == 1:
     self.board[x][y] = 1
     self.check()
     self.turn = -1

  def __str__(self):
    for x in range(len(self.board)):
      line = ''
      for y in range(len(self.board[x])):
        if self.board[x][y] == 0:
          sym = '.'
        elif self.board[x][y] == 1:
          sym = 'O'
        else:
          sym = 'X'
        line += f'{sym} '
      print(f'{line}')
    return ''

def play_game(player1=None,player2=None,human=False):
  board = ttt()
  if (not human):
    #'X' goes first
    #-1 = 'X' 1 = 'O'
    player1.set_player(-1)
    player2.set_player(1)
    while board.win == None:
      output = None
      score = None
      if (board.turn == player1.player):
        output,score = player1.make_move(board)
      else:
        output,score = player2.make_move(board)
      board.play(output[0],output[1])
    if board.win == -1:
      player1.fitness += 15
      player1.games_played += 1
      player2.games_played += 1

    elif board.win == 1:
      player2.fitness += 20
      player2.games_played += 1
      player1.games_played += 1

    else:
      player1.fitness += 5
      player2.fitness += 10
      player1.games_played += 1
      player2.games_played += 1
  else:
    player_turn = None
    while player_turn != "-1" and player_turn != "1":
      player_turn = input("-1 for X and 1 for O:")
      if player_turn != "-1" and player_turn != "1":
        print('invalid input')
    player_turn = int(player_turn)
    if player_turn == -1:
      player1.set_player(1)
    else:
      player1.set_player(-1)
    while board.win == None:
      output = None
      score = None
      if (board.turn == player1.player):
        output,score = player1.make_move(board)
      else:
        print(board)
        row = int(input("row:"))
        col = int(input("col:"))
        output = (row,col)
      board.play(output[0],output[1])
    board.game_end
    print(board)
  return

from torch.nn import functional as F
from torch import nn, optim
import sys
import torch
from IPython.display import clear_output
from torchvision import transforms as tr
import random
import copy

class agent():
  def __init__(self,net):
    self.fitness = 0
    self.brain = net
    self.games_played = 0
    self.player = -1
    self.generation = 0
  def __str__(self):
    print(f'fitness: {self.fitness}')
    return ''
  def set_player(self,sym):
    self.player = sym
  def make_move(self,board):
    valid_moves = board.valid_moves()
    best_move = None
    best_score = None
    for move in valid_moves:
      temp_board = copy.deepcopy(board)
      temp_board.play(move[0],move[1])
      mat = matrix(temp_board)
      with torch.no_grad():
        out = self.brain(mat)
      val = float(out[0])
      val = self.player * val
      if best_score == None or val > best_score:
        best_score = val
        best_move = move
    return best_move,best_score

def generate_agents(pop,net):
  agents = []
  while len(agents) < pop:
    new_net = net()
    agents.append(agent(new_net))
  return agents
    
def takefirst(elm):
  return elm[0]

def sort_agents(agents):
  leaderboard = []
  for agent in agents:
    leaderboard.append((agent.fitness,agent,agent.generation))
  leaderboard.sort(key=takefirst,reverse=True)
  return leaderboard

def elimination(agents):
  for x in range(len(agents)):
    player1 = agents[x]
    for y in range(len(agents)):
      if x != y:
        player2 = agents[y]
        play_game(player1,player2)
    # if x % 10 == 0 :
    #   print(f'agent {x} done')

#bia and weights splicing (Linear):

def reproduction(parent1,parent2,mutation_count=0,energy=0):
  net1 = parent1.brain
  net2 = parent2.brain
  new_net = ttt_net()

  shapes = []
  new_parm = []

  it1 = iter(net1.named_parameters())
  it2 = iter(net2.named_parameters())
  con = True
  while con:
    try:
      name, parm1 = next(it1)
      name, parm2 = next(it2)
    except:
      con = False
      continue
    shapes.append(parm1.shape)
    parm1 = (parm1.detach().numpy().flatten())
    parm2 = (parm2.detach().numpy().flatten())
    new_gen = np.zeros(parm2.shape,dtype="float32")
    for i in range(len(parm2)):
      if (random.uniform(0, 1)>=0.5):
        new_gen[i] = parm2[i]
      else:
        new_gen[i] = parm1[i]
      if (random.uniform(0, 1)<= energy):
        new_gen[i] = new_gen[i]+random.uniform(-.02 - energy, 0.02 + energy)
        mutation_count +=1
    new_parm.append(new_gen)

  i = 0
  new_state = new_net.state_dict()
  for name, parm in new_net.named_parameters():
    with torch.no_grad():
      new_state[name] = (torch.tensor((new_parm[i].reshape(shapes[i])),requires_grad=True))
      i += 1

  new_net.load_state_dict(new_state)
  # new_net = new_net.to(device)

  return agent(new_net),mutation_count

def crossOver(leaderboard,n_child,n_random,generation=0,energy=0):
  mutation_count=0
  newGen = []
  while len(newGen) <= n_child:
    weights = []
    for i in leaderboard:
      weights.append(((i[1].fitness)/leaderboard[0][0])**100)
    weights.sort(reverse=True)
    child = None
    parents = [i for i in range(len(leaderboard))]
    p1 = random.choices(parents,weights=weights,k=1)
    p1 = p1[0]
    parents.remove(p1)
    weights.pop(p1)
    P1 = leaderboard[p1][1]
    p2 = random.choices(parents,weights=weights,k=1)
    p2 = p2[0]
    P2 = leaderboard[p2][1]
    child,mutation_count = reproduction(P1,P2,mutation_count=mutation_count,energy=energy)
    child.generation = generation
    newGen.append(child)
  newGen += generate_agents(n_random,ttt_net)
  i = 0
  while len(newGen) != len(leaderboard):
    newGen.append(leaderboard[i][1])
    leaderboard[i][1].games_played = 0
    leaderboard[i][1].fitness = 0
    i += 1
  print(f'number of mutations: {mutation_count}')
  return newGen
  
def oneVSone(player1=None,player2=None):
  board = ttt()
  #'X' goes first
  #-1 = 'X' 1 = 'O'
  player1.set_player(-1)
  player2.set_player(1)
  while board.win == None:
    output = None
    score = None
    if (board.turn == player1.player):
      output,score = player1.make_move(board)
    else:
      output,score = player2.make_move(board)
    board.play(output[0],output[1])
  if board.win == 1:
    return 1
  elif board.win == -1:
    return -1
  else:
    return 0

from multiprocessing import Process, Queue

class ttt_net(nn.Module):
  def __init__(self):
    super(ttt_net,self).__init__()
    self.layer1 = nn.Linear(3*3*3,10)
    self.layer2 = nn.Linear(10,1)
  def forward(self, x):
    x = x.view(-1,3*3*3)
    x = F.relu(self.layer1(x))
    x = self.layer2(x)
    return torch.tanh(x)

def matrix(board):
  matrix = np.zeros((3,3,3))
  matrix[:,:,2] = board.turn
  for x in range(len(board.board)):
    for y in range(len(board.board[x])):
      if board.board[x][y] == 1:
        matrix[x,y,0] = 1
      elif board.board[x][y] == -1:
        matrix[x,y,1] = 1
  return torch.tensor(matrix).float()

def elimination_ran(agents,test_agents):
  for x in range(len(agents)):
    player1 = agents[x]
    for y in range(len(test_agents)):
        player2 = test_agents[y]
        play_game(player1,player2)

  for x in range(len(agents)):
    player1 = agents[x]
    for y in range(len(test_agents)):
      player2 = test_agents[y]
      play_game(player2,player1)

# device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
# device = torch.cuda.current_device()
agents = generate_agents(100,ttt_net)
test_agents = generate_agents(100,ttt_net)
gen = 0
while gen <= 1000:
  # elimination(agents)
  elimination_ran(agents,test_agents)
  leaderboard = sort_agents(agents)
  print("\n")
  print(leaderboard)
  games = []
  for i in range(len(agents)):
    games.append(oneVSone(player1=leaderboard[0][1],player2=agents[i]))
  for i in range(len(test_agents)):
    games.append(oneVSone(player1=agents[i],player2=leaderboard[0][1])*-1)
  print(f'current geration: {gen}')
  print(f'top_player geration: {leaderboard[0][1].generation}')
  print(f'top_player wins(stand): {games.count(-1)}')
  print(f'top_player loss(stand): {games.count(1)}')
  print(f'ties(stand): {games.count(0)}')
  games = []
  for i in range(len(test_agents)):
    games.append(oneVSone(player1=leaderboard[0][1],player2=test_agents[i]))
  for i in range(len(test_agents)):
    games.append(oneVSone(player1=test_agents[i],player2=leaderboard[0][1])*-1)
  print(f'top_player wins(ran): {games.count(-1)}')
  print(f'top_player loss(ran): {games.count(1)}')
  print(f'ties(ran): {games.count(0)}')
  gen += 1
  torch.save(leaderboard[0][1].brain.state_dict(),'/content/drive/MyDrive/Models/tic_tac_toe_net3')
  agents = crossOver(leaderboard=leaderboard,n_child=60,n_random=10,generation=gen,energy = 0.05)

weights = []
for i in leaderboard:
  weights.append(((i[1].fitness)/leaderboard[0][0])**100)
weights.sort(reverse=True)
print(weights)
parents = [i for i in range(len(leaderboard))]
p1 = random.choices(parents,weights=weights,k=1)
print(p1)

for x in range(len(leaderboard)):
  games = []
  for i in range(len(test_agents)):
    games.append(oneVSone(player1=leaderboard[x][1],player2=test_agents[i]))
  for i in range(len(test_agents)):
    games.append(oneVSone(player1=test_agents[i],player2=leaderboard[x][1])*-1)
  print(f'player {x} wins(ran): {games.count(-1)}')
  print(f'player {x} loss(ran): {games.count(1)}')
  print(f'{x} ties(ran): {games.count(0)}\n')

old_agents = generate_agents(100,ttt_net)
test_agents = generate_agents(20,ttt_net)
gen = 0
while gen <= 150:
  elimination_ran(agents,old_agents)
  leaderboard = sort_agents(agents)
  print("\n")
  print(leaderboard)
  games = []
  for i in range(len(test_agents)):
    games.append(oneVSone(player1=leaderboard[0][1],player2=test_agents[i]))
  for i in range(len(test_agents)):
    games.append(oneVSone(player1=test_agents[i],player2=leaderboard[0][1])*-1)
  print(f'current geration: {gen}')
  print(f'top_player geration: {leaderboard[0][1].generation}')
  print(f'top_player wins: {games.count(-1)}')
  print(f'top_player loss: {games.count(1)}')
  print(f'ties: {games.count(0)}')
  gen += 1
  torch.save(leaderboard[0][1].brain.state_dict(),'/content/drive/MyDrive/Models/tic_tac_toe_net3')
  # old_agents = copy.deepcopy(agents)
  agents = crossOver(leaderboard=leaderboard,n_parents=20,n_random=10,generation=gen)

best_agent = leaderboard[0][1]
print(best_agent.wins)
print(best_agent.games_played)
play_game(player1=best_agent,human=True)